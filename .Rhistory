#Tutorial from below
#https://www.datacamp.com/tutorial/logistic-regression-R
getwd( )
library(tidyverse)
library(caTools)
library(readr)
library(data.table)
library(openxlsx)
# Sample data
data <- data.frame(
ID = c(1, 1, 2, 2, 2),
Category = c("A", "B", "A", "B" ,"C"),
Value = c(10, 20, 30, 40 , 50)
)
data
# Create a pivot table
pivot_table <- pivot_wider(data, id_cols = ID, names_from = Category, values_from = Value)
# Print the pivot table
print(pivot_table)
colnames(pivot_table)
df<-openxlsx::read.xlsx('dataset.xlsx')
datatable <- as.data.table(df)
datatable
doctor_specialty_mapping <- unique(datatable[ , .(doctor_id,specialty)] , by=c('doctor_id','specialty'))
doctor_specialty_mapping
doctor_specialty_mapping [, custom_specialty := paste(specialty,doctor_id)]
doctor_specialty_mapping [,specialty:= NULL]
doctor_specialty_mapping
datatable_2 <- copy(datatable)
datatable_2 <- datatable_2 [ , .(doctor_id,specialty,therapeutic_labeling)]
datatable_2_agg <- datatable_2[ , .N , by =c('doctor_id','therapeutic_labeling')]
datatable_2_agg
#datatable_2_agg[ total_rx:=sum(N) , by='specialty']
datatable_2_agg[, total_rx := sum(N), by = 'doctor_id']
datatable_2_agg[ , rx_percentage := round((N/total_rx),1)]
datatable_2_agg
datatable_2_pivot <- pivot_wider(datatable_2_agg, id_cols = doctor_id, names_from = therapeutic_labeling, values_from = rx_percentage)
datatable_2_pivot
index_column_length <- length(colnames(datatable_2_pivot))
setnafill(datatable_2_pivot[ ,2:index_column_length], fill=0)
datatable_2_pivot
datatable_3_pivot <- merge( datatable_2_pivot, doctor_specialty_mapping , on='doctor_id')
datatable_3_pivot
datatable_3_pivot.index= datatable_3_pivot$custom_specialty
datatable_3_pivot.index
datatable_4_pivot <- datatable_3_pivot %>% select(-c(doctor_id, custom_specialty))
row.names(datatable_4_pivot) <- datatable_3_pivot$custom_specialty
#calculate principal components
results <- prcomp(datatable_4_pivot, scale = TRUE)
#reverse the signs
results$rotation <- -1*results$rotation
#display principal components
results$rotation
#Turn off scientific notation so we can view the decimals
options(scipen=999)
#calculate total variance explained by each principal component
PC_Variations  <- results$sdev^2 / sum(results$sdev^2)
PC_Variations <- round(100 * PC_Variations ,1)
PC_Variations
#reverse the signs of the scores
results$x <- -1*results$x
results$x
class(results$x)
biplot(results, scale = 0 )
biplot(results, expand=10, xlim=c(0.0, 0.0), ylim=c(-0.1, 0.1))
pc_dt <- as.data.table(results$x)
pc_dt <- cbind( datatable_3_pivot$custom_specialty,pc_dt[,.(PC1,PC2)])
pc_dt
#Just graphing the principal component values for samples
ggplot(pc_dt, aes(x=PC1, y=PC2)) +
geom_point() +
geom_text(label=pc_dt$V1 ,angle = 10 , vjust=1 ,size=3.5) + theme_bw()
pc_variances[1]
#Turn off scientific notation so we can view the decimals
options(scipen=999)
#calculate total variance explained by each principal component
pc_variances  <- results$sdev^2 / sum(results$sdev^2)
pc_variances <- round(100 * PC_Variations ,1)
pc_variances
pc_variances[1]
#Turn off scientific notation so we can view the decimals
options(scipen=999)
#calculate total variance explained by each principal component
pc_variances  <- results$sdev^2 / sum(results$sdev^2)
results$sdev^2 / sum(results$sdev^2)
pc_variances <- round(100 * PC_Variations ,1)
pc_variances
#Turn off scientific notation so we can view the decimals
options(scipen=999)
#calculate total variance explained by each principal component
pc_variances  <- results$sdev^2 / sum(results$sdev^2)
results$sdev^2 / sum(results$sdev^2)
pc_variances <- round(10 * PC_Variations , 1)
pc_variances
#Turn off scientific notation so we can view the decimals
options(scipen=999)
#calculate total variance explained by each principal component
pc_variances  <- results$sdev^2 / sum(results$sdev^2)
results$sdev^2 / sum(results$sdev^2)
pc_variances <- round(1 * PC_Variations , 1)
pc_variances
#Turn off scientific notation so we can view the decimals
options(scipen=999)
#calculate total variance explained by each principal component
pc_variances  <- results$sdev^2 / sum(results$sdev^2)
results$sdev^2 / sum(results$sdev^2)
pc_variances <- round( PC_Variations , 1)
pc_variances
pc_variances[1]
#Just graphing the principal component values for samples
ggplot(pc_dt, aes(x=PC1, y=PC2)) +
geom_point() +
xlab(paste("PC1 - ", pc_variances[1], "%", sep="")) +
ylab(paste("PC2 - ", pc_variances[2], "%", sep="")) +
geom_text(label=pc_dt$V1 ,angle = 10 , vjust=1 ,size=3.5) + theme_bw()
#Just graphing the principal component values for samples
ggplot(pc_dt, aes(x=PC1, y=PC2)) +
geom_point() +
xlab(paste("PC1 : ", pc_variances[1], "%", sep="")) +
ylab(paste("PC2 : ", pc_variances[2], "%", sep="")) +
geom_text(label=pc_dt$V1 ,angle = 10 , vjust=1 ,size=3.5) + theme_bw()
