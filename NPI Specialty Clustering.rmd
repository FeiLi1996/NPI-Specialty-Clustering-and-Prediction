
# NPI Specialty Clustering with PCA and K-Mean
## About NPI Specialty Clustering


Knowing a NPI Specialty can give lots of information. For instance, we would expect a cardiologist to have a different prescribing behavior than a psychiatrist.Knowing how  NPIs act based on their specialties can be useful for many reasons. Some reasons are fraud detection and marketing campaigns. This can be helpful in fraud detection because if  a cardiologist is prescribing high percentages of adderall or meth, then we can predict that this person is probably a fraud. If we are promoting a weight loss drug, we would want to target primary care specialties like family medicine, etc . We wouldn't want to target pulmonologist and urologist as their prescribing behaviors are unlikely related to weight loss.

However, sometimes the specialty is unknown or it is known but not very helpful. For example, Nurse Practioner(NP) and Physician assistant(PA) often specialize in a particular field like pain , cardiac stuff or pediatric. Unfortunately healthcare data don't  really track their specialties so they just list them as NP or PA. This is an issue because if a NP prescribes lots of opioid, should we flag the NPI as guaranteed fraud? What if the NP works in a surgical clinic? Furthermore,  if NPs/PAs make up 50% of a local clinical dataset, should we advertise our weight loss medication  to them? What if the local clinic only focus on addiction therapy? Then the marketing team would lose lots of money because the investment would be wasted as addiction therapy isn't related to weight loss.


## About the Data set

This  synthetic dataset gives information about the doctors and their prescriptions. There are only 4 columns. We will use it to visualize their prescription behaviors in a 2D graph via PCA. Then we will try to cluster similiar doctors with or without their reliable specialty titles based on their prescription behaviors with kmeans.

* Attribute Information
  +	rx_id 
      +	__Meaning__: The unique ID for the prescription
      +	__Variable Type__: character
      +	__Possible values__:  any number from 1 to infinity
  +	doctor_id 
      +	__Meaning__: The unique ID of a  doctor 
      +	__Variable Type__: character
      +	__Possible values__:  any number from 1 to infinity
  +	specialty 
      +	__Meaning__: a branch of medicine the clinician is involved with
      +	__Variable Type__: character
      +	__Possible values__:  'cardiologist' , 'general practice', 'nurse practioner',etc
  +	therapeutic_labeling 
      +	__Meaning__: the clinical catergory of the prescription drug
      +	__Variable Type__: character
      +	__Possible values__:  'ocular' , 'bronchodilator', 'cardiology',etc      


# Table of Contents
1. Import Packages
2. Data load and EDA
3. Preparing ML models
4. Models evaluation
5. Model in action and interpretation
6. Conclusion










# 1. Import Packages
```{r}

library(tidyverse)
library(caTools)
library(readr)
library(data.table)
library(openxlsx)
library(factoextra)
library(cluster)


```


# 2.Load data and  EDA

```{r}


df<-openxlsx::read.xlsx('dataset.xlsx')
datatable <- as.data.table(df)
datatable




doctor_specialty_mapping <- unique(datatable[ , .(doctor_id,specialty)] , by=c('doctor_id','specialty'))
doctor_specialty_mapping


doctor_specialty_mapping [, custom_specialty := paste(specialty,doctor_id)] 
doctor_specialty_mapping [,specialty:= NULL]
doctor_specialty_mapping

```

```{r}
datatable_2 <- copy(datatable)

datatable_2 <- datatable_2 [ , .(doctor_id,specialty,therapeutic_labeling)]

datatable_2_agg <- datatable_2[ , .N , by =c('doctor_id','therapeutic_labeling')]
datatable_2_agg


#datatable_2_agg[ total_rx:=sum(N) , by='specialty']

 datatable_2_agg[, total_rx := sum(N), by = 'doctor_id']
 
 datatable_2_agg[ , rx_percentage := round((N/total_rx),1)]
 
 
 datatable_2_agg
```



# 3. Preparing ML models
```{r}

datatable_2_pivot <- pivot_wider(datatable_2_agg, id_cols = doctor_id, names_from = therapeutic_labeling, values_from = rx_percentage)
datatable_2_pivot
```

```{r}

index_column_length <- length(colnames(datatable_2_pivot))
setnafill(datatable_2_pivot[ ,2:index_column_length], fill=0)
datatable_2_pivot
```

```{r}


datatable_3_pivot <- merge( datatable_2_pivot, doctor_specialty_mapping , on='doctor_id')





datatable_3_pivot


datatable_3_pivot.index= datatable_3_pivot$custom_specialty
datatable_3_pivot.index


datatable_4_pivot <- datatable_3_pivot %>% select(-c(doctor_id, custom_specialty))
row.names(datatable_4_pivot) <- datatable_3_pivot$custom_specialty

  
```



```{r}
#calculate principal components
results <- prcomp(datatable_4_pivot, scale = TRUE)

#reverse the signs
results$rotation <- -1*results$rotation

#display principal components
results$rotation

```

```{r}
#Turn off scientific notation so we can view the decimals
options(scipen=999)

#calculate total variance explained by each principal component
pc_variances  <- results$sdev^2 / sum(results$sdev^2)
results$sdev^2 / sum(results$sdev^2)
pc_variances <- round( pc_variances , 1)
pc_variances

```




```{r}


#reverse the signs of the scores
results$x <- -1*results$x

results$x
```

```{r}
class(results$x)

df <- as.data.frame(results$x[ , 1:2])
class(df)
df

biplot(results, scale = 0 ) 
```


```{r}

biplot(results, expand=10, xlim=c(0.0, 0.0), ylim=c(-0.1, 0.1))
```




```{r}

pc_dt <- as.data.table(results$x)
pc_dt <- cbind( datatable_3_pivot$custom_specialty,pc_dt[,.(PC1,PC2)])
pc_dt
```


```{r}
#Just graphing the principal component values for samples

ggplot(pc_dt, aes(x=PC1, y=PC2)) +
  geom_point() +
  xlab(paste("PC1 : ", pc_variances[1], "%", sep="")) +
  ylab(paste("PC2 : ", pc_variances[2], "%", sep="")) +
  geom_text(label=pc_dt$V1 ,angle = 10 , vjust=1 ,size=3.5) + theme_bw()
```


# kmeans clustering


```{r}
fviz_nbclust(pc_dt[ , 2:3], kmeans, method = "wss")

```

```{r}

#make this example reproducible
set.seed(1)

#perform k-means clustering with k = 4 clusters
km <- kmeans(pc_dt[ , 2:3], centers = 4, nstart = 25)

#view results
km



```
```{r}
fviz_cluster(km, data = df)
#fviz_cluster(km, data = df ,,geom="point")  + geom_text(label=pc_dt$V1 ,angle = 10 , vjust=1 ,size=3.5)
```


